package fujiokam
import (
	"github.com/dedis/crypto/abstract"
	"github.com/dedis/crypto/random"
	"github.com/dedis/crypto/nist"
	"math/big"
	"math"
	"crypto/sha256"
)

type FujiOkamBase struct {
	Suite abstract.Suite
	G1 *Point
	G2 *Point
	G3 *Point
	G4 *Point
	G5 *Point
	G6 *Point
	H1 *Point
	alpha1 *big.Int // only server side knows alpha1 ~ alpha6
	alpha2 *big.Int
	alpha3 *big.Int
	alpha4 *big.Int
	alpha5 *big.Int
	alpha6 *big.Int
	N *big.Int
	RandomRadius *big.Int // the secret used in commitment will be chosen from -RandomRadius ~ RnadomRadius
	RandomDiameter *big.Int
	P *big.Int // only server side knows P and Q
	Q *big.Int
}

var bigZero = big.NewInt(0)
var bigOne = big.NewInt(1)
var bigTwo = big.NewInt(2)
var bigFour = big.NewInt(4)
var bigNegOne = big.NewInt(-1)

// genRandomSecret returns a random int from -RandomRadius ~ RandomRadius,
// and it has be in Z*_{p*q}
func (base *FujiOkamBase) genRandomSecret() *big.Int {
	// p := base.P
	// q := base.Q
	// pq := new(big.Int).Mul(p, q)
	// var s *big.Int = nil
	// modp := new(big.Int)
	// modq := new(big.Int)
	// for {
	// 	s = random.Int(base.RandomDiameter, random.Stream)
	// 	s.Sub(s, base.RandomRadius)
	// 	alpha := new(big.Int).Mod(s, pq)
	// 	// (alpha, p) = 1 and (alpha, q) = 1 and alpha != 1
	// 	if alpha.Cmp(bigOne) == 0 {
	// 		continue
	// 	}
	// 	modp.Mod(alpha, p)
	// 	if modp.Cmp(bigZero) == 0 {
	// 		continue
	// 	}
	// 	modq.Mod(alpha, q)
	// 	if modq.Cmp(bigZero) == 0 {
	// 		continue
	// 	}
	// 	break
	// }
	// return s
	s := random.Int(base.RandomDiameter, random.Stream)
	s.Sub(s, base.RandomRadius)
	return s
}

// genGn returns a random gn from <H1>
func (base *FujiOkamBase) genGn() (*Point, *big.Int) {
	alpha := base.genRandomSecret()
	Gn := base.Point().Exp(base.H1, alpha)
	return Gn, alpha
}

// genH returns a random int from Z*_n
func (base *FujiOkamBase) genH() *Point {
	p := base.P
	q := base.Q
	dpPlusOne := new(big.Int).Add(p, p)
	dpPlusOne.Add(dpPlusOne, bigOne)
	dqPlusOne := new(big.Int).Add(q, q)
	dqPlusOne.Add(dqPlusOne, bigOne)
	modRes := new(big.Int)
	var h1 *big.Int = nil
	for {
		h1 = random.Int(base.N, random.Stream)
		if h1.Cmp(bigOne) == 0 {
			continue
		}
		modRes.Mod(h1, dpPlusOne)
		if modRes.Cmp(bigZero) == 0 {
			continue
		}
		modRes.Mod(h1, dqPlusOne)
		if modRes.Cmp(bigZero) == 0 {
			continue
		}
		break
	}
	H1 := base.Point().SetBigInt(h1)
	H1.Mul(H1, H1)
	return H1
}

func CreateMinimumBase(suite abstract.Suite, n *big.Int) (*FujiOkamBase) {
	base := &FujiOkamBase {
		Suite : suite,
		N : n,
	}
	// randomRadius := 2^80 * N
	randomRadius, _ := new(big.Int).SetString("100000000000000000000", 16) // 2^80
	randomRadius.Mul(randomRadius, base.N)
	// randomDiameter := randomRadius * 2
	randomDiameter := new(big.Int).Mul(randomRadius, bigTwo)
	base.RandomRadius = randomRadius
	base.RandomDiameter = randomDiameter
	return base
}

func CreateBase() (*FujiOkamBase) {
	suite := nist.NewAES128SHA256QR512()
	return CreateBaseFromSuite(suite)
}

func CreateBaseFromSuite(suite abstract.Suite) (*FujiOkamBase) {
	p := new(big.Int).SetInt64(3)
	q := new(big.Int).SetInt64(5)
	// n := (2p + 1) * (2q + 1)
	n := new(big.Int).SetInt64(77)
	base := CreateMinimumBase(suite, n)
	base.P = p
	base.Q = q
	
	base.H1 = base.genH()
	base.G1, base.alpha1 = base.genGn()
	base.G2, base.alpha2 = base.genGn()
	base.G3, base.alpha3 = base.genGn()
	base.G4, base.alpha4 = base.genGn()
	base.G5, base.alpha5 = base.genGn()
	base.G6, base.alpha6 = base.genGn()

	return base
}

// sampleZpq returns a random int from Z*_{p*q}
func (base *FujiOkamBase) sampleZpq() *big.Int {
	modRes := new(big.Int)
	var r *big.Int = nil
	for {
		r = random.Int(base.N, random.Stream)
		if r.Cmp(bigOne) == 0 {
			continue
		}
		modRes.Mod(r, base.P)
		if modRes.Cmp(bigZero) == 0 {
			continue
		}
		modRes.Mod(r, base.Q)
		if modRes.Cmp(bigZero) == 0 {
			continue
		}
		break
	}
	return r
}

// ****************************************************************************
// Use zero-knowledge discrete log protocol to prove that Gn is generated by H1
// ****************************************************************************

const GN_HONESTY_PROOF_SIZE = 80

func (base *FujiOkamBase) GenerateGnHonestyProof(secrets []*big.Int, publics []*Point) {
	if len(secrets) != GN_HONESTY_PROOF_SIZE || len(publics) != GN_HONESTY_PROOF_SIZE {
		panic("length check failed")
	}
	for i, _ := range secrets {
		gammar := base.sampleZpq()
		a := base.Point().Exp(base.H1, gammar)
		secrets[i] = gammar
		publics[i] = a
	}
}

func (base *FujiOkamBase) ChallengeGnHonesty(bits []bool) {
	if len(bits) != GN_HONESTY_PROOF_SIZE {
		panic("length check failed")
	}
	for i, _ := range bits {
		bits[i] = random.Bool(random.Stream)
	}
}

func (base *FujiOkamBase) AnswerGnHonesty(bits []bool, secrets []*big.Int, alpha *big.Int, answers []*big.Int) {
	if len(bits) != GN_HONESTY_PROOF_SIZE || len(secrets) != GN_HONESTY_PROOF_SIZE || len(answers) != GN_HONESTY_PROOF_SIZE {
		panic("length check failed")
	}
	for i, b := range bits {
		// answer := secret + b * alpha
		answer := new(big.Int)
		if b == true {
			answer.Add(secrets[i], alpha)
		}else {
			answer.Set(secrets[i])
		}
		answers[i] = answer
	}
}

func (base *FujiOkamBase) CheckGnHonesty(answers []*big.Int, bits []bool, publics[]*Point, Gn *Point) bool {
	if len(answers) != GN_HONESTY_PROOF_SIZE || len(bits) != GN_HONESTY_PROOF_SIZE || len(publics) != GN_HONESTY_PROOF_SIZE {
		panic("length check failed")
	}
	for i, b := range bits {
		answer := answers[i]
		public := publics[i]
		Lside := base.Point().Exp(base.H1, answer)
		var Rside *Point = nil
		if b == true {
			// H1^answer == H1^secert * H1^alpha == public * G1
			Rside = base.Point().Mul(public, Gn)
		}else {
			// H1^answer == H1^secert == public
			Rside = public
		}
		if !Lside.Equal(Rside) {
			return false
		}
	}
	return true
}

func (base *FujiOkamBase) GenerateAllGnHonestyProof() (secrets []*big.Int, publics []*big.Int) {
	W := GN_HONESTY_PROOF_SIZE
	secrets = make([]*big.Int, 6*W)
	points := make([]*Point, 6*W)
	base.GenerateGnHonestyProof(secrets[0*W:1*W], points[0*W:1*W])
	base.GenerateGnHonestyProof(secrets[1*W:2*W], points[1*W:2*W])
	base.GenerateGnHonestyProof(secrets[2*W:3*W], points[2*W:3*W])
	base.GenerateGnHonestyProof(secrets[3*W:4*W], points[3*W:4*W])
	base.GenerateGnHonestyProof(secrets[4*W:5*W], points[4*W:5*W])
	base.GenerateGnHonestyProof(secrets[5*W:6*W], points[5*W:6*W])
	publics = PointArrayToBigIntArray(points)
	return secrets, publics
}

func (base *FujiOkamBase) ChallengeAllGnHonesty() (bits []bool) {
	W := GN_HONESTY_PROOF_SIZE
	bits = make([]bool, 6*W)
	base.ChallengeGnHonesty(bits[0*W:1*W])
	base.ChallengeGnHonesty(bits[1*W:2*W])
	base.ChallengeGnHonesty(bits[2*W:3*W])
	base.ChallengeGnHonesty(bits[3*W:4*W])
	base.ChallengeGnHonesty(bits[4*W:5*W])
	base.ChallengeGnHonesty(bits[5*W:6*W])
	return bits
}

func (base *FujiOkamBase) AnswerAllGnHonesty(bits []bool, secrets []*big.Int, publics []*big.Int) []*big.Int {
	W := GN_HONESTY_PROOF_SIZE
	answers := make([]*big.Int, 6*W)
	base.AnswerGnHonesty(bits[0*W:1*W], secrets[0*W:1*W], base.alpha1, answers[0*W:1*W])
	base.AnswerGnHonesty(bits[1*W:2*W], secrets[1*W:2*W], base.alpha2, answers[1*W:2*W])
	base.AnswerGnHonesty(bits[2*W:3*W], secrets[2*W:3*W], base.alpha3, answers[2*W:3*W])
	base.AnswerGnHonesty(bits[3*W:4*W], secrets[3*W:4*W], base.alpha4, answers[3*W:4*W])
	base.AnswerGnHonesty(bits[4*W:5*W], secrets[4*W:5*W], base.alpha5, answers[4*W:5*W])
	base.AnswerGnHonesty(bits[5*W:6*W], secrets[5*W:6*W], base.alpha6, answers[5*W:6*W])
	return answers
}

func (base *FujiOkamBase) CheckAllGnHonesty(answers []*big.Int, bits []bool, publics []*big.Int) int {
	W := GN_HONESTY_PROOF_SIZE
	points := base.BigIntArrayToPointArray(publics)
	
	if base.CheckGnHonesty(answers[0*W:1*W], bits[0*W:1*W], points[0*W:1*W], base.G1) == false {
		return 1
	}
	if base.CheckGnHonesty(answers[1*W:2*W], bits[1*W:2*W], points[1*W:2*W], base.G2) == false {
		return 2
	}
	if base.CheckGnHonesty(answers[2*W:3*W], bits[2*W:3*W], points[2*W:3*W], base.G3) == false {
		return 3
	}
	if base.CheckGnHonesty(answers[3*W:4*W], bits[3*W:4*W], points[3*W:4*W], base.G4) == false {
		return 4
	}
	if base.CheckGnHonesty(answers[4*W:5*W], bits[4*W:5*W], points[4*W:5*W], base.G5) == false {
		return 5
	}
	if base.CheckGnHonesty(answers[5*W:6*W], bits[5*W:6*W], points[5*W:6*W], base.G6) == false {
		return 6
	}
	return 0
}

// ****************************************************************************
// Decompose integer into sum of three squares
// ****************************************************************************

// Decompose 4x+1 into sum of three squares.
// In other words, find a, b and d, such that 4x+1 = a^2 + b^2 + d^2
// Reference: Legendre's three-square theorem
func decomposeThreeSquareHelper(x int64) (int64, int64, int64) {
	var goal int64 = 4*x+1
	var bound int64 = int64(math.Sqrt(float64(goal)))
	var a, b, d int64
	for a = 0; a <= bound; a++ {
		aa := a * a
		for b = 0; b <= bound; b++ {
			bb := b * b
			if aa + bb > goal {
				continue
			}
			for d = 0; d < bound; d++ {
				dd := d * d
				if aa + bb + dd == goal {
					return a, b, d
				}
			}
		}
	}
	// Should never reach here
	panic(1)
}

func decomposeThreeSquare(x *big.Int) (*big.Int, *big.Int, *big.Int) {
	a, b, d := decomposeThreeSquareHelper(x.Int64())
	return big.NewInt(a), big.NewInt(b), big.NewInt(d)
}

// ****************************************************************************
// Commitment
// ****************************************************************************

func (base *FujiOkamBase) Commit(x *big.Int) (*Point, *big.Int) {
	r := base.genRandomSecret()
	commitx := base.CommitWithR(x, r)
	return commitx, r
}

func (base *FujiOkamBase) CommitWithR(x, r *big.Int) *Point {
	commitx := base.Point().Exp(base.G1, x)
	tp := base.Point().Exp(base.H1, r)
	commitx.Mul(commitx, tp)
	return commitx
}

// ****************************************************************************
// Non-negative argument
// ****************************************************************************

type ARGnonneg struct {
	Commitrx *big.Int
	C *big.Int
	Cr *big.Int
	R *big.Int
	X_ *big.Int
	A_ *big.Int
	B_ *big.Int
	D_ *big.Int
	R_ *big.Int
}

func (base*FujiOkamBase) ProveNonneg(x *big.Int, commitx *Point, rc *big.Int) *ARGnonneg {
	commitrx, C, Cr, R, x_, a_, b_, d_, r_ := base.ProveNonnegHelper(x, commitx, rc)
	return &ARGnonneg{
		Commitrx: &commitrx.V,
		C: &C.V,
		Cr: &Cr.V,
		R: R,
		X_: x_,
		A_: a_,
		B_: b_,
		D_: d_,
		R_: r_,
	}
}

func (base *FujiOkamBase) ProveNonnegHelper(x *big.Int, commitx *Point, rc *big.Int) (*Point, *Point, *Point, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int, *big.Int) {
	if x.Cmp(bigZero) < 0 {
		panic("x must be non-negative");
	}
	a, b, d := decomposeThreeSquare(x)
	ti := new(big.Int)
	tp := base.Point()
	// rx, ra, rb, rd := random
	rx := base.genRandomSecret()
	ra := base.genRandomSecret()
	rb := base.genRandomSecret()
	rd := base.genRandomSecret()
	// delta := 4*rx - 2*a*ra - 2*b*rb - 2*d*rd
	delta := new(big.Int)
	delta.Mul(bigFour, rx)
	ti.Mul(bigTwo, a).Mul(ti, ra)
	delta.Sub(delta, ti)
	ti.Mul(bigTwo, b).Mul(ti, rb)
	delta.Sub(delta, ti)
	ti.Mul(bigTwo, d).Mul(ti, rd)
	delta.Sub(delta, ti)
	// r := random
	r := base.genRandomSecret()
	// C := g2^x * g3^a * g4^b * g5^d * g6^delta * h^r (mod n)
	C := base.Point()
	C.Exp(base.G2, x)
	tp.Exp(base.G3, a)
	C.Mul(C, tp)
	tp.Exp(base.G4, b)
	C.Mul(C, tp)
	tp.Exp(base.G5, d)
	C.Mul(C, tp)
	tp.Exp(base.G6, delta)
	C.Mul(C, tp)
	tp.Exp(base.H1, r)
	C.Mul(C, tp)
	// rr := random
	rr := base.genRandomSecret()
	// Cr := g2^rx * g3^rx * g3^ra * g4^rb * g5^rd * g6^(-ra^2-rb^2-rd^2) * h^rr (mod n)
	Cr := base.Point()
	Cr.Exp(base.G2, rx)
	tp.Exp(base.G3, ra)
	Cr.Mul(Cr, tp)
	tp.Exp(base.G4, rb)
	Cr.Mul(Cr, tp)
	tp.Exp(base.G5, rd)
	Cr.Mul(Cr, tp)
	ti.Mul(ra, ra).Neg(ti)
	tp.Exp(base.G6, ti)
	Cr.Mul(Cr, tp)
	ti.Mul(rb, rb).Neg(ti)
	tp.Exp(base.G6, ti)
	Cr.Mul(Cr, tp)
	ti.Mul(rd, rd).Neg(ti)
	tp.Exp(base.G6, ti)
	Cr.Mul(Cr, tp)
	tp.Exp(base.H1, rr)
	Cr.Mul(Cr, tp)
	ti.SetInt64(-1)
	tp.Exp(base.G6, ti)
	// commitrx = g^rx * h^rrx (mod n)
	commitrx, rrx := base.Commit(rx)
	// e = hash(commitx, C, Cr)
	h := sha256.New()
	h.Write(commitx.V.Bytes())
	h.Write(C.V.Bytes())
	h.Write(Cr.V.Bytes())
	eBuf := h.Sum(nil)
	e := new(big.Int)
	e.SetBytes(eBuf)
	// x' := xe + rx
	x_ := new(big.Int)
	x_.Mul(x, e).Add(x_, rx)
	// a' := a*e + ra
	a_ := new(big.Int)
	a_.Mul(a, e)
	a_.Add(a_, ra)
	// b' := b*e + rb
	b_ := new(big.Int)
	b_.Mul(b, e).Add(b_, rb)
	// d' := d*e + rd
	d_ := new(big.Int)
	d_.Mul(d, e).Add(d_, rd)
	// r' := r*e + rr
	r_ := new(big.Int)
	r_.Mul(r, e).Add(r_, rr)
	// R := e*rx + rrx
	R := new(big.Int)
	R.Mul(e, rc).Add(R, rrx)
	return commitrx, C, Cr, R, x_, a_, b_, d_, r_
}

func (base *FujiOkamBase) VerifyNonneg(commitx *Point, arg *ARGnonneg) bool {
	commitrx := base.Point().SetBigInt(arg.Commitrx)
	C := base.Point().SetBigInt(arg.C)
	Cr := base.Point().SetBigInt(arg.Cr)
	return base.VerifyNonnegHelper(commitx, commitrx, C, Cr, arg.R, arg.X_, arg.A_, arg.B_, arg.D_, arg.R_)
}

func (base *FujiOkamBase) VerifyNonnegHelper(commitx, commitrx, C, Cr *Point, R, x_, a_, b_, d_, r_ *big.Int) bool {
	// e := hash(commitx, C, Cr)
	h := sha256.New()
	h.Write(commitx.V.Bytes())
	h.Write(C.V.Bytes())
	h.Write(Cr.V.Bytes())
	eBuf := h.Sum(nil)
	e := new(big.Int)
	e.SetBytes(eBuf)
	// delta' := e*(4*x' + e) - a'^2 - b'^2 - d'^2
	delta_ := new(big.Int)
	ti := new(big.Int)
	ti.Mul(bigFour, x_).Add(ti, e)
	delta_.Mul(e, ti)
	ti.Mul(a_, a_)
	delta_.Sub(delta_, ti)
	ti.Mul(b_, b_)
	delta_.Sub(delta_, ti)
	ti.Mul(d_, d_)
	delta_.Sub(delta_, ti)

	// Lside := C^e * Cr (mod n)
	Lside := base.Point()
	Lside.Exp(C, e).Mul(Lside, Cr)
	// Rside := g2^x' * g3^a' * g4^b' * g5^d' * g6^delta' * h^r' (mod n)
	Rside := base.Point()
	Rside.Exp(base.G2, x_)
	tp := base.Point()
	tp.Exp(base.G3, a_)
	Rside.Mul(Rside, tp)
	tp.Exp(base.G4, b_)
	Rside.Mul(Rside, tp)
	tp.Exp(base.G5, d_)
	Rside.Mul(Rside, tp)
	tp.Exp(base.G6, delta_)
	Rside.Mul(Rside, tp)
	tp.Exp(base.H1, r_)
	Rside.Mul(Rside, tp)
	// check Lside == Rside
	if !Lside.Equal(Rside) {
		return false
	}

	// Lside := commitx^e * commitrx
	Lside.Exp(commitx, e)
	Lside.Mul(Lside, commitrx)
	// Rside := g^x' * h^R
	Rside.Exp(base.G1, x_)
	tp.Exp(base.H1, R)
	Rside.Mul(Rside, tp)
	// check Lside == Rside
	if !Lside.Equal(Rside) {
		return false
	}

	return true
}